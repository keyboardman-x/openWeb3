### 交易流程图

```
1. 用户发起交易
   |
   ↓
2. 创建新的 EVM 实例
   |
   ↓
3. 加载合约字节码
   |
   ↓
4. 分配 Stack 空间（1024 slots）
   |
   ↓
5. 执行合约代码
   |
   ↓
6. 更新区块链状态（如果需要）
   |
   ↓
7. 销毁 EVM 实例
```

**详细说明**

1. 用户发起交易
	- 用户签名交易
	- 设定 gas limit 和 gas price
	- 指定目标合约地址和调用数据

2. 创建新的 EVM 实例
	- 为每笔交易创建独立的 EVM 环境
	- 初始化执行上下文
	- 准备内存和存储空间

3. 加载合约字节码
	- 从区块链状态中读取合约字节码
	- 将字节码加载到 EVM 中
	- 准备执行环境

4. 分配 Stack 空间
	- 分配 1024 个 slots
	- 每个 slot 256 位
	- 用于存储临时计算结果

5. 执行合约代码
	- 逐条执行操作码
	- 进行状态检查和 gas 计算
	- 处理函数调用和返回值

6. 更新区块链状态
	- 写入存储变更
	- 更新账户余额
	- 触发事件日志

7. 销毁 EVM 实例
	- 清理内存
	- 释放资源
	- 返回执行结果

**注意事项**
- 整个过程是原子性的：要么全部成功，要么全部失败
- Gas 限制贯穿整个执行过程
- 状态变更只在交易成功执行后才会提交

### EVM 存储结构
```
1. Stack (栈)
+----------------+
| 基本类型的值    | <- 函数内的局部变量
| 引用的地址      | <- 指向其他存储位置
+----------------+


2. Memory (内存)
+----------------+
| 临时数据       | <- 函数执行期间的临时数据
| 函数参数       | <- memory 类型的参数
| 返回数据       | <- 函数返回值
+----------------+


3. Storage (存储)
+----------------+
| 状态变量       | <- 合约的永久存储数据
| 映射数据       | <- mapping 数据
| 数组数据       | <- storage 数组
+----------------+
```

EVM Stack (固定大小的栈空间)
```
+------------------+
|     空闲空间     | <- 1024 个槽位（slots）
|        ⬇        |    每个槽位 32 字节（256 位）
+------------------+
|    当前使用空间   | <- 随函数执行压入/弹出
+------------------+
```

Memory：
  存在于 EVM 执行环境中
  临时性的，交易执行完就清除
  线性寻址（0x00, 0x20, 0x40...）

Storage：
  存在于区块链状态中
  永久性的，写入区块
  使用 slot 和 keccak256 哈希定位


### 基本类型
在 Solidity 中，直接存储在栈（Stack）中的基本类型包括：

#### 1. 整型（Integer）
```solidity
contract StackTypes {
    function integerTypes() public pure {
        // 所有整型都存储在栈中
        uint256 a = 1;
        uint8 b = 2;
        int256 c = -1;
        int8 d = -2;
    }
}
```

#### 2. 布尔型（Boolean）
```solidity
function booleanTypes() public pure {
    bool isTrue = true;
    bool isFalse = false;
}
```

#### 3. 地址（Address）
```solidity
function addressTypes() public pure {
    address addr = 0x123...;
    address payable payableAddr = payable(0x123...);
}
```

4. 固定大小字节数组（Fixed-size Bytes）
```solidity
function bytesTypes() public pure {
    bytes1 b1 = 0x12;
    bytes32 b32 = 0x123...;
}
```

5. 枚举（Enum）
```solidity
enum Status { Active, Inactive }

function enumTypes() public pure {
    Status status = Status.Active;  // 实际存储为 uint8
}

```

**重要说明：**
1. 这些类型在函数（相关文档：数据位置修饰符）调用时：
  - 作为参数传递时是值传递
  - 不需要指定 memory 等位置修饰符
  ```solidity
    // ✅ 正确：不需要 memory
    function example(uint256 num, bool flag, address addr)
    public pure {
        // ...
    }

    // ❌ 错误：不能为基本类型指定 memory
    function wrong(uint256 memory num) public pure {
        // ...
    }
 ```

2. 大小限制：
```solidity
function stackLimits() public pure {
    // EVM 栈深度限制为 1024
    // 每个值占用一个栈槽（32字节）
}
```


3. 与引用类型对比：
```solidity
contract TypeComparison {
    // 基本类型：直接存储在栈中
    uint256 public stackVar = 123;
    
    // 引用类型：存储引用在栈中，数据在其他位置
    string public stringVar = "hello";  // 数据在存储中
    uint256[] public arrayVar;          // 数据在存储中
}
```

4. 在函数（文档地址：数据位置修饰符）中的使用：
```solidity
contract StackUsage {
    function calculate() public pure returns (uint256) {
        // 这些变量都在栈中
        uint256 a = 1;
        uint256 b = 2;
        uint256 c = a + b;
        
        return c;
    } // 函数结束时栈变量自动清除
}
```


**注意事项：**
1. 栈变量的生命周期仅限于函数执行期间
2. 栈变量不需要手动管理内存
3. 栈操作的 gas 成本较低
4. 需要注意栈深度限制（1024层）

**这些类型的特点：**
1. 大小固定
2. 值类型（非引用）
3. 操作简单直接
4. gas 成本低

### 主要的引用类型：
特点：
在栈中：只存储引用（地址/指针）
实际数据：存储在 Memory 或 Storage 中

1. 数组（Array）
```solidity
contract ArrayExample {
    // Storage 数组（状态变量）
    uint[] public storageArray;  // 存储在链上
    
    function example() public {
        // Memory 数组（局部变量）
        uint[] memory memoryArray = new uint[](3);
        
        // 栈中只存储数组的引用（指针）
        // 实际数据在 Memory 或 Storage 中
    }
}
```

2. 字符串（String）
```solidity
contract StringExample {
    // Storage 字符串
    string public storageStr = "hello";  // 存储在链上
    
    function example() public pure {
        // Memory 字符串
        string memory memoryStr = "world";
        
        // 栈中存储字符串的引用
        // 实际字符串数据在 Memory 或 Storage
    }
}
```

3. 结构体（Struct）
``` solidity
contract StructExample {
    struct Person {
        string name;
        uint age;
    }
    
    // Storage 结构体
    Person public storagePerson;
    
    function example() public {
        // Memory 结构体
        Person memory memoryPerson = Person("Alice", 20);
        
        // 栈中存储结构体的引用
        // 实际数据在 Memory 或 Storage
    }
}
```

4. 映射（Mapping）
```solidity
contract MappingExample {
    // 只能声明为 Storage
    mapping(address => uint) public balances;
    
    function example() public {
        // ❌ 不能创建 Memory 映射
        // mapping(address => uint) memory memoryMap;  // 错误
        
        // 只能在 Storage 中使用
        balances[msg.sender] = 100;
    }
}
```

5. 不固定长度的字节数组（bytes）
```solidity
// 引用类型示例
bytes public dynamicBytes;     // 动态字节数组，存储在存储区(storage)
bytes32 public fixedBytes;     // 固定长度字节数组，是值类型

function example() public {
    // 动态分配内存
    dynamicBytes = new bytes(2);
    dynamicBytes[0] = 0x12;
    dynamicBytes[1] = 0x34;
    
    // 可以改变长度
    dynamicBytes.push(0x56);
}
```

**存储位置总结：**
1. Storage（链上存储）
- 状态变量
- 永久存储
- Gas 成本高
string public storageStr;  // 状态变量自动存储在 Storage


2. Memory（临时内存）
- 函数参数
- 函数（相关文档：数据位置修饰符）内的临时变量
- 函数返回值
function example(string memory param) public {
    string memory temp = "temp";
}


3. 栈（Stack）
- 只存储引用（指针）
- 指向 Memory 或 Storage 的实际数据
// 栈中存储的是引用，指向实际数据
uint[] memory arr = new uint[](3);


**注意事项：**
1. 引用类型必须指定存储位置（memory/storage）
2. Mapping 只能用于 Storage
3. 状态变量默认是 Storage
4. 函数参数默认是 Memory
5. Storage 到 Memory 会创建副本